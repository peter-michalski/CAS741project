\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}

\newcommand{\famname}{Lattice Boltzmann Solvers}

\newcounter{mnum}
\newcommand{\mthemnum}{M\themnum}

\begin{document}

\title{Module Interface Specification for \famname}

\author{Peter Michalski}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Nov. 25, 2019 & 1.0 & Initial Document\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See CA Documentation for \famname \ \citep{LBM_CA_PM}.

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
\famname , which provides a library of services based on Lattice Boltzmann Methods (LBM).
LBM are a family of fluid dynamics algorithms for simulating single-phase and multiphase fluid flows, often incorporating additional physical complexities \citep{chen1998lattice}.

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found \href{https://github.com/peter-michalski/LatticeBoltzmannSolvers}{here} \citep{LBM_PM}.

\section{Notation}

\wss{You should describe your notation.  You can use what is below as
  a starting point.}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \famname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \famname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \famname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

~\newpage

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
	\centering
	\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
		\toprule
		\textbf{Level 1} & \textbf{Level 2}\\
		\midrule
		
		{Hardware-Hiding Module}
		& M1: Hardware Hiding Module\\
		\midrule
		
		\multirow{7}{0.3\textwidth}{Behaviour-Hiding Module}
		& M2: System Control Module\\
		& M3: Input Reading Module\\
		& M4: Input Checking Module\\
		& M5: LBM Control Module\\
		& M6: Streaming Module\\
		& M7: Collision Module\\ 
		& M8: Problem Module\\
		& M9: Lattice Module\\
		& M10: Boundary Module\\
		\midrule
		
		\multirow{1}{0.3\textwidth}{Software Decision Module}
		& M11: Output Module\\
		\bottomrule
		
	\end{tabular}
	\caption{Module Hierarchy}
	\label{TblMH}
\end{table}


~\newpage

\section{MIS of M1: Hardware Hiding Module} \label{HHModule} 

The secrets of this module are the data structure and algorithms used to implement the virtual hardware.

\subsection{Module}

Hardware Hiding

\subsection{Uses}
N/A

\subsection{Syntax}
N/A

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Access Programs}
N/A

\subsection{Semantics}
N/A

\subsubsection{State Variables}

N/A
\subsubsection{Environment Variables}

The module has external interaction with the environment when either the Output Module M11 (Section \ref{OUModule}) or Input Reading Module M3 (Section \ref{IRModule}) require its services for reading inputs or writing outputs.

\subsubsection{Assumptions}

M11 (Section \ref{OUModule}) or M3 (Section \ref{IRModule}) have called the modules services.

\subsubsection{Access Routine Semantics}
N/A

\subsubsection{Local Functions}
N/A

\newpage

\section{MIS of M2: System Control Module} \label{SCModule}

The secret of this module is the algorithm to control \famname.

\subsection{Module}

System Control

\subsection{Uses}

\begin{itemize}
	\item Output (Section \ref{OUModule})
	\item Input Reading (Section \ref{IRModule})
	\item LBM Control (Section \ref{LCModule})
	\item Problem Parameter (Section \ref{PRModule})
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Access Programs}
N/A

\subsection{Semantics}

\subsubsection{State Variables}
LIBRARY\_IN: string\\
DIMENSIONS\_IN: $\mathbb{N}$\\
VEL\_DIR\_IN: $\mathbb{N}$\\
inputValues: array of strings, $\mathbb{R}$, $\mathbb{N}$\\
LBMout: array of $\mathbb{R}$

\subsubsection{Environment Variables}

N/A

\subsubsection{Assumptions}

The user has run the {\famname} program.

\subsubsection{Access Routine Semantics}

N/A

\subsubsection{Local Functions}

\begin{center}
	\begin{tabular}{p{4cm} p{4cm} p{2cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		LIBRARY\_IN & array of strings, $\mathbb{R}$, $\mathbb{N}$ & string &- \\
		DIMENSIONS\_IN & array of strings, $\mathbb{R}$, $\mathbb{N}$ & $\mathbb{N}$ &- \\
		VEL\_DIR\_IN & array of strings, $\mathbb{R}$, $\mathbb{N}$ & $\mathbb{N}$ &- \\
		\hline
	\end{tabular}
\end{center}


~\newpage

\section{MIS of M3: Input Reading Module} \label{IRModule} 

The secret of this module is the algorithm that gathers the input data.

\subsection{Module}

Input Reading

\subsection{Uses}

\begin{itemize}
	\item Input Checking
	\item Hardware Hiding
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
inputValues: array of strings, $\mathbb{R}$, $\mathbb{N}$\\


\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		inputArray & & array of strings, $\mathbb{R}$, $\mathbb{N}$ & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

Input\_Location: string

\subsubsection{Environment Variables}

N/A

\subsubsection{Assumptions}

The System Control Module M2 (Section \ref{SCModule}) has called the inputArray function of this module.

\subsubsection{Access Routine Semantics}

\noindent inputArray():
\begin{itemize}
	\item output: inputValues := $+$(inputValues[i] $|$ string $\cup$ $\mathbb{R}$ $\cup$ $\mathbb{N}$ $|$ :readline)
	\item exception: N/A
\end{itemize}

The function will read all lines from the input file and place each value into an array in the form array[key:string][value: string $\cup$ $\mathbb{R}$ $\cup$ $\mathbb{N}$]. There is no input into the file, the output will be the array. The location of the input file is in the state variable Input\_Location.

\subsubsection{Local Functions}

\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		open & string & object & NOT\_FOUND ERR\_READ\\
		readline & object & - & NO\_LINES OUT\_BOUNDS\\
		\hline
	\end{tabular}
\end{center}

\newpage

\section{MIS of M4: Input Checking Module} \label{ICModule} 

This secret of this module is the algorithm that checks if input values fall within allowable parameters.

\subsection{Module}

Input Checking

\subsection{Uses}
N/A

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		verifyInputs & string array & & OUT\_OF\_BOUNDS UNKN\_PARM \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\textit{LIBRARIES}: set of strings: \{pyLBM\}\\
\textit{DIMENSIONS}: set of $\mathbb{N}$: \{2\}\\
\textit{VEL\_DIRS}: set of $\mathbb{N}$: \{9\}\\
\textit{REYNOLDS\_MIN}: $\mathbb{R}$: \{0.001\}\\
\textit{REYNOLDS\_MAX}: $\mathbb{R}$: \{5000\}\\
\textit{DENSITY\_MIN}: $\mathbb{R}$: \{0.0708\}\\
\textit{DENSITY\_MIN}: $\mathbb{R}$: \{13.6\}\\
\textit{BULK\_VIS\_MIN}: $\mathbb{R}$: \{0.0001\}\\
\textit{BULK\_VIS\_MIN}: $\mathbb{R}$: \{20000\}\\
\textit{SHEAR\_VIS\_MIN}: $\mathbb{R}$: \{0.001\}\\
\textit{SHEAR\_VIS\_MIN}: $\mathbb{R}$: \{20000\}\\
\textit{TIME\_MIN}: $\mathbb{N}$: \{1\}\\
\textit{LIBRARY\_IN}: string\\
\textit{DIMENSIONS\_IN}: $\mathbb{N}$\\
\textit{VEL\_DIR\_IN}: $\mathbb{N}$\\
$Re$: $\mathbb{R}$\\
$\rho$: $\mathbb{R}$\\
$\eta_b$: $\mathbb{R}$\\
$\eta_s$: $\mathbb{R}$\\
$t$: $\mathbb{N}$\\
$\mathrm{a}$: $\mathbb{R}$\\
$c_s$: $\mathbb{R}$\\
$\mathrm{e}$: $\mathbb{R}$\\
$F$: $\mathbb{R}$\\
$kg$: $\mathbb{R}$\\
$A$: $\mathbb{R}$\\
\textbf{u}: $\mathbb{R}$\\

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}

The Input Reading Module M3 (Section \ref{IRModule}) has called the verifyInputs function of this module.

\subsubsection{Access Routine Semantics}

\noindent verifyInputs():
\begin{itemize}
	\item output: N/A
	\item exception: OUT\_OF\_BOUNDS := if inputValue(i$_2$) $>$ parm\_max $\cup$ $<$ parm\_min $\Rightarrow$ ERROR
	\item exception: UNKN\_PARM := if inputValue(i$_1$) != known\_parm $\Rightarrow$ ERROR
\end{itemize}

The function will iterate through each inputValue array key and check if the key is known to the program, and if the values of known keys falls within an acceptable range.

\subsubsection{Local Functions}

N/A

\newpage

\section{MIS of M5: LBM Control Module} \label{LCModule}

The secret of this module is the algorithm which controls the LBM library.

\subsection{Module}

LBM Control

\subsection{Uses}

\begin{itemize}
	\item Streaming
	\item Collision
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		vortVal & array of strings, $\mathbb{R}$, $\mathbb{N}$ & array of $\mathbb{R}$ & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

array of vorticity vector values

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}

The System Control Module M2 (Section \ref{SCModule}) has called the vortVal function of this module.

\subsubsection{Access Routine Semantics}

\noindent vortVal():
\begin{itemize}
	\item output: vortVal := (inputValues[0...n]$|$ array of $\mathbb{N}$$|$:streaming()*collision())
	\item exception: N/A
\end{itemize}

The function will calculate the vorticity vector values, iterating through each velocity direction, calling the streaming and collision module functions.

\subsubsection{Local Functions}

N/A

\newpage

\section{MIS of M6: Streaming Module} \label{STModule}

The secret of this module is the algorithm to calculate the streaming pf particles.

\subsection{Module}

Streaming

\subsection{Uses}
N/A
\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		bgkCollision & array of strings, $\mathbb{R}$, $\mathbb{N}$ & $\mathbb{R}$ & NAN\_ERROR \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Environment Variables}

N/A

\subsubsection{Assumptions}

The LBM Control Module M5 (Section \ref{LCModule}) has called the bgkCollision function of this module.

\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
	\item output: bgkValue := (inputValues[0...n]$|$$\mathbb{N}$$|$:relatUpdate()*equilDistrib()*relaxRate())
	\item exception: if $|$var$|$ $>$ $|$type$|$ $\cup$ $<$ $|$type$|$ $\Rightarrow$ ERROR
\end{itemize}

The function calculates the Bhatnagar-Gross-Krook collision operator value for each velocity direction (i) using the functions for the relaxation rate towards equilibrium, equilibrium distribution function, and relaxation update.

\subsubsection{Local Functions}

\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		relatUpdate & array of strings, $\mathbb{R}$, $\mathbb{N}$ & $\mathbb{R}$ & NAN\_ERROR \\
		equilDistrib & array of strings, $\mathbb{R}$, $\mathbb{N}$ & $\mathbb{R}$ & NAN\_ERROR \\
		relaxRate & $\mathbb{R}$, $\mathbb{N}$ & $\mathbb{R}$ & NAN\_ERROR \\
		\hline
	\end{tabular}
\end{center}

\newpage

\section{MIS of M7: Collision Module} \label{COModule} 

The secret of this module is the algorithm to calculate the collision of particles.

\subsection{Module}

Collision

\subsection{Uses}
N/A

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{3cm} p{4cm} p{2cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		streamingFunc & array of strings, $\mathbb{R}$, $\mathbb{N}$ & $\mathbb{R}$ & NAN\_ERROR \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}

The LBM Control Module M5 (Section \ref{LCModule}) has called the streamingFunc function of this module.

\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
	\item output: strmValue := (inputValues[0...n]$|$$\mathbb{N}$$|$:streamingFunc())
	\item exception: if $|$var$|$ $>$ $|$type$|$ $\cup$ $<$ $|$type$|$ $\Rightarrow$ ERROR
\end{itemize}

The function calculates the streaming step value for each velocity direction (i) using the probability density function.

\subsubsection{Local Functions}

\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		prbDnsFunc & array of $\mathbb{R}$, $\mathbb{N}$ & $\mathbb{R}$ & NAN\_ERROR \\
		\hline
	\end{tabular}
\end{center}

\newpage

\section{MIS of M8: Problem Module} \label{PRModule}

The secret of this module is the structure of the LBM input parameters.

\subsection{Module}

Problem Parameter

\subsection{Uses}

\begin{itemize}
	\item Lattice
	\item Boundary
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		formatInput & array of $\mathbb{R}$, $\mathbb{N}$ & array of $\mathbb{R}$, $\mathbb{N}$ & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}

The System Control Module M2 (Section \ref{SCModule}) has called the formatInput function of this module.

\subsubsection{Access Routine Semantics}

\noindent vortVal():
\begin{itemize}
	\item output: vortVal := (inputValues$|$ array of strings and $\mathbb{N}$$|$:setLattice()*boundFunc())
	\item exception: N/A
\end{itemize}

The function will set up the structure for the LBM input parameters based on the library that the user has requested. The function will use the lattice and boundary module functions.

\subsubsection{Local Functions}
N/A

\newpage

\section{MIS of M9: Lattice Module} \label{LAModule} 

The secret of this module is the structure of the lattice model.

\subsection{Module}

Lattice

\subsection{Uses}
N/A

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		setLattice & array of $\mathbb{R}$ & array of $\mathbb{N}$ & No\_LATTICE \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

Array of tuples: parameterValues:= $<$$\mathbb{R}$$>$$<$$\mathbb{R}$$>$$<$$\mathbb{R},\mathbb{N}_0$...$\mathbb{N}_n$$>$ 

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}

The Problem Module M8 (Section \ref{PRModule}) has called the setLattice function of this module.

\subsubsection{Access Routine Semantics}

\noindent setLattice():
\begin{itemize}
	\item output: output := (DIMENSIONS\_IN, VEL\_DIR\_IN $|$ array of $\mathbb{N}$$|$:parameterValues)
	\item exception: if DIMENSIONS\_IN $\cap$ VEL\_DIR\_IN $\notin$ parameterValues $\Rightarrow$ NO\_LATTICE
\end{itemize}

The function sets coefficient weight data for the selected lattice model.

\subsubsection{Local Functions}
N/A

\newpage

\section{MIS of M10: Boundary Module} \label{BOModule}

The secret of this module is the structure of the model boundary.

\subsection{Module}

Boundary

\subsection{Uses}
N/A

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A
\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		boundFunc & array of $\mathbb{R}$ & array of $\mathbb{R}$ & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

N/A

\subsubsection{Environment Variables}

N/A

\subsubsection{Assumptions}

The Problem Module M8 (Section \ref{PRModule}) has called the boundFunc function of this module.

\subsubsection{Access Routine Semantics}

\noindent boundFunc():
\begin{itemize}
	\item output: output := (inputValues $|$ array of $\mathbb{N}$$|$:inputValues[])
	\item exception: N/A
\end{itemize}

The function sets coefficient weight data for the selected lattice model.

\subsubsection{Local Functions}

N/A

\newpage

\section{MIS of M11: Output Module} \label{OUModule} 

The algorithm to convert the LBM output into an image.

\subsection{Module}

Output

\subsection{Uses}

\begin{itemize}
	\item System Control Module
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
N/A

\subsubsection{Exported Access Programs}

\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		imageFunc & array of $\mathbb{R}$ & image format & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
N/A

\subsubsection{Environment Variables}
N/A

\subsubsection{Assumptions}

The System Control Module M2 (Section \ref{PRModule}) has called the imageFunc function of this module.

\subsubsection{Access Routine Semantics}

\noindent imageFunc():
\begin{itemize}
	\item output: (LBMout $|$ image format $|$:external image rendering function)
	\item exception: N/A
\end{itemize}

The function converts the information from the LBM algorithm output into an image format.

\subsubsection{Local Functions}
N/A

\newpage

\bibliographystyle {plainnat}
\bibliography{../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\end{document}